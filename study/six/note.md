# 接口、lambda、内部类

## 接口

1. 接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。

2. 接口可以被扩展，并支持多实现。

3. 接口中的方法会自动的设置为public，接口中的域会被自动的设为public static final。

4. 抽象类的不足在于，类只能被单继承，但是一个类却可以实现多个接口。

5. 静态方法允许被添加到接口中，但是不建议。通常的做法是将静态方法放在伴随类中。

6. 默认方法。可以给接口方法提供一个默认实现，语法上必须用default修饰符标记这样的方法。有点类似之前的对一个接口实现一个空实现的类。

7. Comparable 接口更加简单，只要实现Comparable接口的对象就成为一个可以比较的对象，但是需要修改源代码，使用Comparator的好处是不需要修改被比较类的代码，而是另外实现了一个比较器，其更加通用以及具备更优的复用性。

## lambda表达式

1. 函数式接口：只有一个抽象方法的接口。一般需要这种接口的对象时，可以提供一个lambda表达式。对于需要这种接口的对象时，就可以提供一个lambda表达式。

2. 方法引用。例子：System.out::println 是一个方法引用等价于lambda表达式：x -> System.out.println(x)。可以在方法引用使用this参数，使用super也是合法的。方法引用即再次精简lambda的写法。
  其有三种情况：1、object::instanceMethod 2、Class::staticMethod 3、Class::instanceMethod

3. 这货和回调函数及其的像

4. 变量的作用域。Java中lambda就是闭包。lambda捕获的变量必须是实际上的最终变量，（1. 引用值不会改变的变量 2. 这个变量不可能在外部改变）

## 内部类

1. 按照作用域划分为：
  1.1. 成员内部类：实例内部类、静态内部类
  1.2. 局部内部类：匿名内部类
2. 使用：
  2.1. 静态内部类：
    a. 可以通过完整的类名直接访问静态内部类的静态成员。
    b. 静态内部类之中可以定义静态变量和实例变量。
    c. 静态内部类的实例不会自动持有外部类的特定实例的引用，在创建内部类的实例时，不必创建外部类的实例。
    d. 静态内部类内部可以直接访问外部类中所有的静态成员，访问实例变量的话就要通过实例来访问。
  2.2. 实例内部类
    a. 构建实例内部类的时候要求外部类的对象先存在
    b. 实例内部类可以访问外部的实例成员变量和方法
    c.
3. 声明在接口中的内部类自动成为static 和public 类

## 问题

1. 实现Comparator接口重写compare方法再将这个实例传递到Arrays.sort的第二个参数。那么这个compare方法是会默认执行的？
